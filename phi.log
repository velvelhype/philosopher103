task
---------------------------
うーん必ずフォーク二つ持ってるけどいいんかな
一人事例にも対応しないといけないっぽい
→ほんとに？　確認する

free考えてないw
→initの時だけだからいいか

エラーケース考えてないw
ーatoi問題ありそや

ファイル分割

相談乗ってもらう

for文変える

ワカモレチェック

ワカモレノームチェック

最終確認してもらう

-------------------------
log
-------------------------
食事時間のあとでカウントすればいいや
全員が食事回数達さないとだめなんだw
変えなきゃ
ていうことはやっぱ定期的に巡回すればいいんだな
配列でeat_countを作って、そこにそれぞれ数を入れさせる、全ての配列の数がeat_limitを上回ったら
終了か


死ぬ時のメッセージをかく　監視用のはmainに書いた
ー　経過時間で殺せるように
->あれ、経過時間取れなくねw
経過時間取るためのスレッド作るか

-　食事回数で殺せる

-　監督スレッド、死んでるかを確認する
→これは結局mainでかいたw

-　thinkの時間どうする？→これ意味がわからない　何言ってるの
	ああ指定がないからどうするってことか、待機させるしかないよね
	ていうかできてるんじゃない？

-　引数の時間に対応、飢餓時間、食事、睡眠時間

やらなければいけないことを把握

最初から見直しだなー
大体できてんじゃね？
対応範囲とかみるか
アクションに時間とか渡すか

timerにusleep噛ませると遅延なくなるの面白い

遅延の原因は何？　とりあえずほっとこ・・・

フォークのint配列をロックかけて0,1にしたりするか
そして実際に回してみる

実際にデッドロックしてみたい

うんやっぱりフォークをintの配列で持った方がわかりやすいなー

pdfみるかー
そして資料スライドも一回見てやってみる
そして聞く

mutexで遊ぶかな 何やってるかを把握しよう
３つスレッド立てて、フォーク使って食べたりする感じのを作ろう

とりあえず哲学者にIDは振れた

どうやって優先順位つけるとかもわかってない

スレッドを哲学者分立ててみるか・・・

pthreadの配列と、そいつがどれくらい食べてないかを把握する
必要ありにけり・・・　どう実装しようか
pthreadで実行する関数に数を数えさせる？

哲学者の数だけスレッドを立てる
５回たてるなら5回、それぞれに番号を振る

それぞれのスレッドは食事、睡眠、思考を繰り返す
初めの食事をするまでには特に何もしていないがちゃんと死ぬ

一定時間食事に失敗、食事回数に達したら死ぬ、誰か死んだら全員死ぬ
終わり

---------------------------
logs
---------------------------
あれ、これ寿命ないんか、あれある気がする？？?　どっちや
->
最初はwaitさせればいいのか？
とにかくpdf準拠だな・・・あと採点項目どうしたものか
もしそうなら
eat sleep think
wait eat sleep
wait wait eat sleep

→寿命ねえわw　じゃあ食べてない時間だけ測ればいいじゃん
寿命の存在がわからん
time_to_die: is in milliseconds,
 if a philosopher doesn’t start eating ’time_to_die’
milliseconds after starting his last meal 
or the beginning of the simulation, it dies
始まりの時間がわけわからん・・・　一度食べ始めると不死の存在ではないのか

哲学者が最後の食事からtime_to_die ミリ秒食べていない場合、
もしくはシミュレーション実行時からtime_to_die　ミリ秒食べずに過ごした場合
アウトー

まずは引数を納めていくところから、

懸念
ワカモレじゃないとバグんじゃね？
バグじゃねえな
